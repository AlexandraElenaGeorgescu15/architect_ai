"""Testing Examples (Unit, Integration, E2E) - 15 examples"""

TESTING_EXAMPLES = [
    {
        "instruction": "Generate comprehensive Jest unit tests for React component.",
        "input": "Test: UserForm component with validation, submission, error handling",
        "output": (
            "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\n"
            "import userEvent from '@testing-library/user-event';\n"
            "import { UserForm } from './UserForm';\n"
            "\n"
            "describe('UserForm', () => {\n"
            "  const mockOnSubmit = jest.fn();\n"
            "\n"
            "  beforeEach(() => {\n"
            "    jest.clearAllMocks();\n"
            "  });\n"
            "\n"
            "  it('renders all form fields', () => {\n"
            "    render(<UserForm onSubmit={mockOnSubmit} />);\n"
            "    \n"
            "    expect(screen.getByLabelText(/name/i)).toBeInTheDocument();\n"
            "    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();\n"
            "    expect(screen.getByRole('button', { name: /submit/i })).toBeInTheDocument();\n"
            "  });\n"
            "\n"
            "  it('shows validation errors for empty fields', async () => {\n"
            "    render(<UserForm onSubmit={mockOnSubmit} />);\n"
            "    \n"
            "    const submitButton = screen.getByRole('button', { name: /submit/i });\n"
            "    fireEvent.click(submitButton);\n"
            "\n"
            "    await waitFor(() => {\n"
            "      expect(screen.getByText(/name is required/i)).toBeInTheDocument();\n"
            "      expect(screen.getByText(/email is required/i)).toBeInTheDocument();\n"
            "    });\n"
            "\n"
            "    expect(mockOnSubmit).not.toHaveBeenCalled();\n"
            "  });\n"
            "\n"
            "  it('validates email format', async () => {\n"
            "    const user = userEvent.setup();\n"
            "    render(<UserForm onSubmit={mockOnSubmit} />);\n"
            "    \n"
            "    const emailInput = screen.getByLabelText(/email/i);\n"
            "    await user.type(emailInput, 'invalid-email');\n"
            "    \n"
            "    const submitButton = screen.getByRole('button', { name: /submit/i });\n"
            "    await user.click(submitButton);\n"
            "\n"
            "    await waitFor(() => {\n"
            "      expect(screen.getByText(/invalid email format/i)).toBeInTheDocument();\n"
            "    });\n"
            "  });\n"
            "\n"
            "  it('submits form with valid data', async () => {\n"
            "    const user = userEvent.setup();\n"
            "    const formData = { name: 'John Doe', email: 'john@example.com' };\n"
            "    \n"
            "    render(<UserForm onSubmit={mockOnSubmit} />);\n"
            "    \n"
            "    await user.type(screen.getByLabelText(/name/i), formData.name);\n"
            "    await user.type(screen.getByLabelText(/email/i), formData.email);\n"
            "    await user.click(screen.getByRole('button', { name: /submit/i }));\n"
            "\n"
            "    await waitFor(() => {\n"
            "      expect(mockOnSubmit).toHaveBeenCalledWith(formData);\n"
            "    });\n"
            "  });\n"
            "\n"
            "  it('disables submit button while submitting', async () => {\n"
            "    const user = userEvent.setup();\n"
            "    mockOnSubmit.mockImplementation(\n"
            "      () => new Promise(resolve => setTimeout(resolve, 1000))\n"
            "    );\n"
            "    \n"
            "    render(<UserForm onSubmit={mockOnSubmit} />);\n"
            "    \n"
            "    await user.type(screen.getByLabelText(/name/i), 'John');\n"
            "    await user.type(screen.getByLabelText(/email/i), 'john@example.com');\n"
            "    \n"
            "    const submitButton = screen.getByRole('button', { name: /submit/i });\n"
            "    await user.click(submitButton);\n"
            "\n"
            "    expect(submitButton).toBeDisabled();\n"
            "    expect(screen.getByText(/submitting/i)).toBeInTheDocument();\n"
            "  });\n"
            "\n"
            "  it('displays server error message', async () => {\n"
            "    const user = userEvent.setup();\n"
            "    const errorMessage = 'Email already exists';\n"
            "    mockOnSubmit.mockRejectedValue(new Error(errorMessage));\n"
            "    \n"
            "    render(<UserForm onSubmit={mockOnSubmit} />);\n"
            "    \n"
            "    await user.type(screen.getByLabelText(/name/i), 'John');\n"
            "    await user.type(screen.getByLabelText(/email/i), 'john@example.com');\n"
            "    await user.click(screen.getByRole('button', { name: /submit/i }));\n"
            "\n"
            "    await waitFor(() => {\n"
            "      expect(screen.getByText(errorMessage)).toBeInTheDocument();\n"
            "    });\n"
            "  });\n"
            "});"
        ),
    },
    {
        "instruction": "Generate Pytest integration test for API endpoint.",
        "input": "Test: POST /api/users endpoint with authentication, validation, database checks",
        "output": (
            "import pytest\n"
            "from fastapi.testclient import TestClient\n"
            "from sqlalchemy.orm import Session\n"
            "from app.main import app\n"
            "from app.models import User\n"
            "from app.database import get_db\n"
            "\n"
            "@pytest.fixture\n"
            "def client(db_session: Session):\n"
            "    def override_get_db():\n"
            "        try:\n"
            "            yield db_session\n"
            "        finally:\n"
            "            pass\n"
            "    \n"
            "    app.dependency_overrides[get_db] = override_get_db\n"
            "    return TestClient(app)\n"
            "\n"
            "@pytest.fixture\n"
            "def auth_headers(client):\n"
            "    # Create test user and login\n"
            "    response = client.post(\n"
            "        \"/api/auth/register\",\n"
            "        json={\n"
            "            \"email\": \"admin@example.com\",\n"
            "            \"password\": \"SecurePassword123!\",\n"
            "            \"role\": \"admin\"\n"
            "        }\n"
            "    )\n"
            "    token = response.json()[\"access_token\"]\n"
            "    return {\"Authorization\": f\"Bearer {token}\"}\n"
            "\n"
            "class TestCreateUser:\n"
            "    def test_create_user_success(self, client, auth_headers, db_session):\n"
            "        payload = {\n"
            "            \"name\": \"John Doe\",\n"
            "            \"email\": \"john@example.com\",\n"
            "            \"password\": \"SecurePass123!\"\n"
            "        }\n"
            "        \n"
            "        response = client.post(\n"
            "            \"/api/users\",\n"
            "            json=payload,\n"
            "            headers=auth_headers\n"
            "        )\n"
            "        \n"
            "        assert response.status_code == 201\n"
            "        data = response.json()\n"
            "        assert data[\"email\"] == payload[\"email\"]\n"
            "        assert data[\"name\"] == payload[\"name\"]\n"
            "        assert \"password\" not in data  # Password should not be returned\n"
            "        assert \"id\" in data\n"
            "        \n"
            "        # Verify database\n"
            "        user = db_session.query(User).filter_by(email=payload[\"email\"]).first()\n"
            "        assert user is not None\n"
            "        assert user.name == payload[\"name\"]\n"
            "    \n"
            "    def test_create_user_without_auth(self, client):\n"
            "        response = client.post(\n"
            "            \"/api/users\",\n"
            "            json={\"email\": \"test@example.com\", \"password\": \"pass\"}\n"
            "        )\n"
            "        \n"
            "        assert response.status_code == 401\n"
            "        assert \"not authenticated\" in response.json()[\"detail\"].lower()\n"
            "    \n"
            "    def test_create_user_duplicate_email(self, client, auth_headers, db_session):\n"
            "        payload = {\"email\": \"duplicate@example.com\", \"password\": \"SecurePass123!\"}\n"
            "        \n"
            "        # Create first user\n"
            "        client.post(\"/api/users\", json=payload, headers=auth_headers)\n"
            "        \n"
            "        # Attempt to create duplicate\n"
            "        response = client.post(\"/api/users\", json=payload, headers=auth_headers)\n"
            "        \n"
            "        assert response.status_code == 422\n"
            "        assert \"already exists\" in response.json()[\"detail\"].lower()\n"
            "    \n"
            "    @pytest.mark.parametrize(\"invalid_email\", [\n"
            "        \"not-an-email\",\n"
            "        \"@example.com\",\n"
            "        \"user@\",\n"
            "        \"\",\n"
            "    ])\n"
            "    def test_create_user_invalid_email(self, client, auth_headers, invalid_email):\n"
            "        response = client.post(\n"
            "            \"/api/users\",\n"
            "            json={\"email\": invalid_email, \"password\": \"SecurePass123!\"},\n"
            "            headers=auth_headers\n"
            "        )\n"
            "        \n"
            "        assert response.status_code == 422\n"
            "        assert \"email\" in response.json()[\"detail\"][0][\"loc\"]\n"
            "    \n"
            "    @pytest.mark.parametrize(\"weak_password\", [\n"
            "        \"short\",\n"
            "        \"alllowercase\",\n"
            "        \"ALLUPPERCASE\",\n"
            "        \"NoNumbers!\",\n"
            "    ])\n"
            "    def test_create_user_weak_password(self, client, auth_headers, weak_password):\n"
            "        response = client.post(\n"
            "            \"/api/users\",\n"
            "            json={\"email\": \"test@example.com\", \"password\": weak_password},\n"
            "            headers=auth_headers\n"
            "        )\n"
            "        \n"
            "        assert response.status_code == 422\n"
            "        assert \"password\" in response.json()[\"detail\"][0][\"loc\"]"
        ),
    },
]

