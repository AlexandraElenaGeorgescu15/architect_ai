[
  {
    "version": 1,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "Mocked API Content",
    "metadata": {
      "model_used": "codellama:7b-instruct-q4_K_M",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_0795d4b1",
      "attempts": [
        {
          "model": "codellama:7b-instruct-q4_K_M",
          "provider": "ollama",
          "content": "Mocked API Content",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='2412829348432'>",
          "retry": 0
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T17:32:09.331982",
    "is_current": false
  },
  {
    "version": 2,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "Mocked API Content",
    "metadata": {
      "model_used": "codellama:7b-instruct-q4_K_M",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_bb69c01b",
      "attempts": [
        {
          "model": "codellama:7b-instruct-q4_K_M",
          "provider": "ollama",
          "content": "Mocked API Content",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='2498727388432'>",
          "retry": 0
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T17:33:23.591611",
    "is_current": false
  },
  {
    "version": 3,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "Mocked API Content",
    "metadata": {
      "model_used": "codellama:7b-instruct-q4_K_M",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_aa19231f",
      "attempts": [
        {
          "model": "codellama:7b-instruct-q4_K_M",
          "provider": "ollama",
          "content": "Mocked API Content",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='1826656562384'>",
          "retry": 0
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T17:34:32.947214",
    "is_current": false
  },
  {
    "version": 4,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "Mocked API Content",
    "metadata": {
      "model_used": "codellama:7b-instruct-q4_K_M",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_68351dbe",
      "attempts": [
        {
          "model": "codellama:7b-instruct-q4_K_M",
          "provider": "ollama",
          "content": "Mocked API Content",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='2217404866512'>",
          "retry": 0
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T17:37:06.716217",
    "is_current": false
  },
  {
    "version": 5,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "Mocked API Content",
    "metadata": {
      "model_used": "codellama:7b-instruct-q4_K_M",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_04a2a924",
      "attempts": [
        {
          "model": "codellama:7b-instruct-q4_K_M",
          "provider": "ollama",
          "content": "Mocked API Content",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='2814402037776'>",
          "retry": 0
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T17:38:33.742391",
    "is_current": false
  },
  {
    "version": 6,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "Mocked API Content",
    "metadata": {
      "model_used": "codellama:7b-instruct-q4_K_M",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_527a323d",
      "attempts": [
        {
          "model": "codellama:7b-instruct-q4_K_M",
          "provider": "ollama",
          "content": "Mocked API Content",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='2356990740112'>",
          "retry": 0
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T17:41:06.634012",
    "is_current": false
  },
  {
    "version": 7,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "Mocked API Content",
    "metadata": {
      "model_used": "codellama:7b-instruct-q4_K_M",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_e4fffc58",
      "attempts": [
        {
          "model": "codellama:7b-instruct-q4_K_M",
          "provider": "ollama",
          "content": "Mocked API Content",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='1989772610896'>",
          "retry": 0
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T17:45:09.085249",
    "is_current": false
  },
  {
    "version": 8,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "Mocked API Content",
    "metadata": {
      "model_used": "codellama:7b-instruct-q4_K_M",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_d53e96a9",
      "attempts": [
        {
          "model": "codellama:7b-instruct-q4_K_M",
          "provider": "ollama",
          "content": "Mocked API Content",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='2331215680336'>",
          "retry": 0
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T17:49:49.319093",
    "is_current": false
  },
  {
    "version": 9,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "Mocked API Content",
    "metadata": {
      "model_used": "codellama:7b-instruct-q4_K_M",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_6ef9a041",
      "attempts": [
        {
          "model": "codellama:7b-instruct-q4_K_M",
          "provider": "ollama",
          "content": "Mocked API Content",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='1536644255376'>",
          "retry": 0
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T17:52:19.837057",
    "is_current": false
  },
  {
    "version": 10,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "As an expert architect and developer assistant, I understand the critical importance of robust frontend testing, especially when integrating with APIs. This document outlines a strategy and provides examples for generating **Custom API Frontend Tests**, focusing on scenarios beyond basic component rendering, ensuring your application behaves correctly under specific business logic, complex data flows, and various API interaction patterns.\n\n---\n\n## API Frontend Test Strategy: Custom Scenarios\n\n### 1. Document Title\n**Custom API Frontend Test Suite: Product Management Dashboard**\n\n### 2. Introduction\nThis document defines a custom test suite for a frontend application, specifically targeting its interaction with backend APIs. The goal is to go beyond generic unit tests by focusing on end-to-end user flows, complex data transformations, error handling, and specific business logic that relies on API responses. These tests simulate real-world user interactions and various API states to ensure the frontend behaves as expected, providing a reliable and consistent user experience.\n\n**Target Application Example:** A \"Product Management Dashboard\" allowing users to view, create, edit, and delete products, manage inventory, and view analytics.\n\n### 3. Key Principles & Best Practices for Custom Tests\n\n*   **Focus on User Journeys:** Test complete user flows, not just isolated components.\n*   **Mock API Responses Realistically:** Use tools like `msw` (Mock Service Worker) to intercept network requests and return controlled, realistic API responses (success, error, loading states). Avoid direct mocking of `fetch` or `axios` globally, as it can be brittle.\n*   **Test Asynchronous Operations:** Ensure proper handling of loading states, data fetching, and race conditions.\n*   **Isolate Frontend Logic:** While testing API integration, aim to keep the tests focused on the frontend's reaction to API responses, not on validating the backend itself.\n*   **Prioritize Critical Paths:** Focus custom tests on the most important user flows and core business functionalities.\n*   **Clear, Descriptive Test Names:** Names should explain *what* is being tested and *why*.\n*   **Cleanup Between Tests:** Ensure each test starts with a clean slate to prevent side effects.\n*   **Leverage Testing Libraries:** Use tools like `@testing-library/react` (for React) or similar for other frameworks, which encourage testing user-facing behavior rather than implementation details.\n\n### 4. Assumptions\n*   **Frontend Framework:** React (examples will use `react-testing-library` and `jest`).\n*   **API Mocking Library:** `msw` (Mock Service Worker) for intercepting network requests.\n*   **Styling:** CSS Modules or Styled Components (not directly tested, but assumes existence).\n*   **Routing:** React Router (or equivalent).\n*   **State Management:** Context API, Redux, Zustand, or similar is used (tests will interact with the UI, abstracting the specific implementation).\n*   **Development Server:** A local development environment is running where the frontend can be rendered.\n\n### 5. Test Environment & Tools (Example Setup)\n\n*   **Test Runner:** Jest\n*   **DOM Testing Library:** `@testing-library/react`\n*   **API Mocking:** `msw` (Mock Service Worker)\n*   **Assertion Library:** Jest's built-in matchers\n*   **Utility Libraries:** `@testing-library/user-event` (for simulating user interactions)\n\n**`src/mocks/handlers.js` (MSW Request Handlers):**\n```javascript\nimport { rest } from 'msw';\n\nconst API_BASE_URL = 'http://localhost:3001/api'; // Or your actual API base URL\n\nexport const handlers = [\n  // Products API\n  rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n    const statusFilter = req.url.searchParams.get('status');\n    let products = [\n      { id: 'p1', name: 'Laptop Pro', price: 1200, stock: 50, status: 'available' },\n      { id: 'p2', name: 'Mechanical Keyboard', price: 150, stock: 0, status: 'out_of_stock' },\n      { id: 'p3', name: 'Wireless Mouse', price: 75, stock: 120, status: 'available' },\n      { id: 'p4', name: 'Webcam HD', price: 100, stock: 10, status: 'low_stock' },\n    ];\n\n    if (statusFilter) {\n      products = products.filter(p => p.status === statusFilter);\n    }\n\n    return res(\n      ctx.status(200),\n      ctx.json(products)\n    );\n  }),\n\n  rest.get(`${API_BASE_URL}/products/:id`, (req, res, ctx) => {\n    const { id } = req.params;\n    const product = { id: id, name: `Product ${id}`, price: 100, stock: 10, status: 'available' };\n    if (id === 'p1') {\n      return res(ctx.status(200), ctx.json({ id: 'p1', name: 'Laptop Pro', price: 1200, stock: 50, status: 'available' }));\n    }\n    if (id === 'p_nonexistent') {\n      return res(ctx.status(404), ctx.json({ message: 'Product not found' }));\n    }\n    return res(ctx.status(200), ctx.json(product));\n  }),\n\n  rest.post(`${API_BASE_URL}/products`, (req, res, ctx) => {\n    const { name, price, stock, status } = req.body;\n    if (!name || !price || !stock) {\n      return res(ctx.status(400), ctx.json({ message: 'Missing required fields' }));\n    }\n    return res(\n      ctx.status(201),\n      ctx.json({ id: 'new-product-id', name, price, stock, status: status || 'available' })\n    );\n    // return res(ctx.status(500), ctx.json({ message: 'Failed to create product' })); // Example error response\n  }),\n\n  rest.put(`${API_BASE_URL}/products/:id`, (req, res, ctx) => {\n    const { id } = req.params;\n    const { name, price, stock, status } = req.body;\n    if (id === 'p_forbidden') {\n      return res(ctx.status(403), ctx.json({ message: 'Permission denied' }));\n    }\n    return res(\n      ctx.status(200),\n      ctx.json({ id, name, price, stock, status })\n    );\n  }),\n\n  rest.delete(`${API_BASE_URL}/products/:id`, (req, res, ctx) => {\n    const { id } = req.params;\n    if (id === 'p_error_delete') {\n      return res(ctx.status(500), ctx.json({ message: 'Internal server error during deletion' }));\n    }\n    return res(ctx.status(204)); // No content for successful deletion\n  }),\n\n  // User/Auth API (for permissions example)\n  rest.get(`${API_BASE_URL}/user/permissions`, (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json({ roles: ['viewer', 'editor'] })\n    );\n  }),\n  // ... other API handlers\n];\n```\n**`src/setupTests.js` (Jest Setup File):**\n```javascript\nimport '@testing-library/jest-dom';\nimport { server } from './mocks/server.js';\n\n// Establish API mocking before all tests.\nbeforeAll(() => server.listen());\n\n// Reset any request handlers that we may add during the tests,\n// so they don't affect other tests.\nafterEach(() => server.resetHandlers());\n\n// Clean up after the tests are finished.\nafterAll(() => server.close());\n```\n\n### 6. Custom API Frontend Test Cases\n\n#### Category 1: Complex Data Fetching & Conditional Display\n\n**Scenario 1.1: Displaying Product List with Status Indicators**\n*   **Description:** When fetching a list of products, the frontend should correctly display product details and apply distinct visual styles (e.g., greyed out, \"Out of Stock\" badge) based on their `status` or `stock` quantity received from the API.\n*   **API Endpoint:** `GET /products`\n*   **Expected Behavior:**\n    *   Products with `status: 'available'` should appear normally.\n    *   Products with `status: 'out_of_stock'` should be visually distinct (e.g., greyed out, show \"Out of Stock\" label).\n    *   Products with `status: 'low_stock'` should show a warning indicator (e.g., \"Low Stock\" label).\n*   **Test Steps:**\n    1.  Mock `GET /products` to return a mix of 'available', 'out_of_stock', and 'low_stock' products.\n    2.  Render the `ProductListPage` component.\n    3.  Wait for products to load.\n    4.  Assert that the 'available' product is displayed normally.\n    5.  Assert that the 'out_of_stock' product is greyed out or shows an \"Out of Stock\" label.\n    6.  Assert that the 'low_stock' product shows a \"Low Stock\" warning.\n\n**Test Example (ProductListPage.test.js):**\n```javascript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport { server } from '../mocks/server';\nimport { rest } from 'msw';\nimport ProductListPage from '../components/ProductListPage'; // Assume this component exists\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\ndescribe('ProductListPage - Custom Data Display', () => {\n  it('should display products with correct status indicators', async () => {\n    // Custom mock for this specific test case\n    server.use(\n      rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        return res(\n          ctx.status(200),\n          ctx.json([\n            { id: 'p1', name: 'Laptop Pro', price: 1200, stock: 50, status: 'available' },\n            { id: 'p2', name: 'Mechanical Keyboard', price: 150, stock: 0, status: 'out_of_stock' },\n            { id: 'p3', name: 'Wireless Mouse', price: 75, stock: 10, status: 'low_stock' },\n          ])\n        );\n      })\n    );\n\n    render(<ProductListPage />);\n\n    // Check loading state first\n    expect(screen.getByText(/Loading products.../i)).toBeInTheDocument();\n\n    // Wait for the products to appear\n    await waitFor(() => expect(screen.getByText(/Laptop Pro/i)).toBeInTheDocument());\n\n    // Assert status indicators\n    const laptopPro = screen.getByText(/Laptop Pro/i);\n    expect(laptopPro).toBeInTheDocument();\n    expect(laptopPro).not.toHaveClass('product-out-of-stock'); // Assuming CSS class for styling\n\n    const mechanicalKeyboard = screen.getByText(/Mechanical Keyboard/i);\n    expect(mechanicalKeyboard).toBeInTheDocument();\n    // Assuming a specific text or role for 'out of stock' indicator\n    expect(screen.getByText(/Out of Stock/i)).toBeInTheDocument();\n    // expect(mechanicalKeyboard).toHaveClass('product-out-of-stock'); // If visual style is applied directly\n\n    const wirelessMouse = screen.getByText(/Wireless Mouse/i);\n    expect(wirelessMouse).toBeInTheDocument();\n    // Assuming a specific text for 'low stock' indicator\n    expect(screen.getByText(/Low Stock \\(10\\)/i)).toBeInTheDocument();\n  });\n\n  it('should display an empty state message when no products are returned', async () => {\n    server.use(\n      rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json([]));\n      })\n    );\n\n    render(<ProductListPage />);\n    await waitFor(() => expect(screen.getByText(/No products found/i)).toBeInTheDocument());\n    expect(screen.queryByText(/Laptop Pro/i)).not.toBeInTheDocument(); // Ensure no products are rendered\n  });\n});\n```\n\n#### Category 2: Multi-Step Workflow with API Dependencies\n\n**Scenario 2.1: Create Product & Immediately View Details (Post-redirect/Post-success Fetch)**\n*   **Description:** A user creates a new product, and upon successful creation, the frontend navigates to the detail page of the newly created product. This involves a `POST` request followed by a `GET` request.\n*   **API Endpoints:** `POST /products`, `GET /products/:id`\n*   **Expected Behavior:**\n    1.  User fills out the form and submits.\n    2.  `POST /products` is called.\n    3.  On success, the frontend redirects to `/products/:newProductId`.\n    4.  A `GET /products/:newProductId` request is made.\n    5.  The details of the newly created product are displayed.\n*   **Test Steps:**\n    1.  Mock `POST /products` to return a success response with a `newProductId`.\n    2.  Mock `GET /products/:newProductId` to return the details of the newly created product.\n    3.  Render the `CreateProductPage` component.\n    4.  Fill the form fields.\n    5.  Click the \"Create Product\" button.\n    6.  Assert that the loading state is shown.\n    7.  Assert that the `GET /products/:newProductId` request is made (e.g., by waiting for its content to appear).\n    8.  Assert that the `ProductDetailPage` for the new product is rendered with the correct data.\n\n**Test Example (CreateProductPage.test.js):**\n```javascript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { server } from '../mocks/server';\nimport { rest } from 'msw';\nimport { MemoryRouter, Route, Routes } from 'react-router-dom'; // For routing context\nimport CreateProductPage from '../components/CreateProductPage';\nimport ProductDetailPage from '../components/ProductDetailPage'; // Assuming this component exists\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\ndescribe('CreateProductPage - Multi-step Workflow', () => {\n  it('should create a product and navigate to its detail page', async () => {\n    const newProductId = 'prod-xyz-123';\n    const newProductName = 'New Super Gadget';\n    const newProductPrice = 99.99;\n    const newProductStock = 500;\n\n    // Mock the POST request for creating a product\n    server.use(\n      rest.post(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        return res(\n          ctx.status(201),\n          ctx.json({ id: newProductId, name: newProductName, price: newProductPrice, stock: newProductStock, status: 'available' })\n        );\n      }),\n      // Mock the GET request for fetching the newly created product's details\n      rest.get(`${API_BASE_URL}/products/${newProductId}`, (req, res, ctx) => {\n        return res(\n          ctx.status(200),\n          ctx.json({ id: newProductId, name: newProductName, price: newProductPrice, stock: newProductStock, status: 'available' })\n        );\n      })\n    );\n\n    render(\n      <MemoryRouter initialEntries={['/products/create']}>\n        <Routes>\n          <Route path=\"/products/create\" element={<CreateProductPage />} />\n          <Route path=\"/products/:id\" element={<ProductDetailPage />} />\n        </Routes>\n      </MemoryRouter>\n    );\n\n    // Fill the form\n    await userEvent.type(screen.getByLabelText(/Product Name/i), newProductName);\n    await userEvent.type(screen.getByLabelText(/Price/i), newProductPrice.toString());\n    await userEvent.type(screen.getByLabelText(/Stock/i), newProductStock.toString());\n\n    // Click the create button\n    await userEvent.click(screen.getByRole('button', { name: /Create Product/i }));\n\n    // Expect navigation and details of the new product to be displayed\n    await waitFor(() => {\n      expect(screen.getByText(`Product Details: ${newProductName}`)).toBeInTheDocument();\n      expect(screen.getByText(`Price: $${newProductPrice}`)).toBeInTheDocument();\n      expect(screen.getByText(`Stock: ${newProductStock}`)).toBeInTheDocument();\n    });\n\n    // Ensure the create form is no longer visible\n    expect(screen.queryByLabelText(/Product Name/i)).not.toBeInTheDocument();\n  });\n});\n```\n\n#### Category 3: Error Handling & Permission-Based UI\n\n**Scenario 3.1: \"Delete Product\" Button - Permissions & API Error**\n*   **Description:** The \"Delete Product\" button should only be visible and enabled for users with 'admin' permissions. If an admin tries to delete a product and the API returns an error, a user-friendly error message should be displayed.\n*   **API Endpoints:** `GET /user/permissions` (or JWT check), `DELETE /products/:id`\n*   **Expected Behavior:**\n    1.  If user is not 'admin', the delete button is not visible or disabled.\n    2.  If user is 'admin', the delete button is visible and enabled.\n    3.  If `DELETE /products/:id` fails (e.g., 500 status), an error message (e.g., \"Failed to delete product. Please try again.\") appears.\n    4.  If `DELETE /products/:id` succeeds, the product is removed from the list, and a success message appears.\n*   **Test Steps:**\n    1.  **Test 1 (No Permissions):** Mock `GET /user/permissions` to return non-admin roles. Render `ProductDetailPage`. Assert delete button is absent/disabled.\n    2.  **Test 2 (With Permissions, Delete Success):** Mock `GET /user/permissions` to return admin roles. Mock `DELETE /products/:id` to succeed (204). Render `ProductDetailPage`. Click delete. Assert success message and product removal.\n    3.  **Test 3 (With Permissions, Delete Failure):** Mock `GET /user/permissions` to return admin roles. Mock `DELETE /products/:id` to fail (500). Render `ProductDetailPage`. Click delete. Assert error message.\n\n**Test Example (ProductDetailPage.test.js):**\n```javascript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { server } from '../mocks/server';\nimport { rest } from 'msw';\nimport { MemoryRouter, Route, Routes } from 'react-router-dom';\nimport ProductDetailPage from '../components/ProductDetailPage';\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\n// Helper to render the component with routing context\nconst renderWithRouter = (ui, { route = '/' } = {}) => {\n  window.history.pushState({}, 'Test page', route);\n  return render(\n    <MemoryRouter initialEntries={[route]}>\n      <Routes>\n        <Route path=\"/products/:id\" element={ui} />\n        <Route path=\"/products\" element={<div>Product List Page (Redirect Target)</div>} />\n      </Routes>\n    </MemoryRouter>\n  );\n};\n\ndescribe('ProductDetailPage - Custom Permissions & Error Handling', () => {\n  const productId = 'p1';\n  const productName = 'Laptop Pro';\n\n  beforeEach(() => {\n    // Default product fetch mock for the detail page\n    server.use(\n      rest.get(`${API_BASE_URL}/products/${productId}`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json({ id: productId, name: productName, price: 1200, stock: 50, status: 'available' }));\n      })\n    );\n  });\n\n  it('should hide the delete button for non-admin users', async () => {\n    // Mock user permissions to be non-admin\n    server.use(\n      rest.get(`${API_BASE_URL}/user/permissions`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json({ roles: ['viewer'] })); // No admin role\n      })\n    );\n\n    renderWithRouter(<ProductDetailPage />, { route: `/products/${productId}` });\n\n    await waitFor(() => expect(screen.getByText(`Product Details: ${productName}`)).toBeInTheDocument());\n\n    expect(screen.queryByRole('button', { name: /Delete Product/i })).not.toBeInTheDocument();\n  });\n\n  it('should display and allow deletion for admin users', async () => {\n    // Mock user permissions to be admin\n    server.use(\n      rest.get(`${API_BASE_URL}/user/permissions`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json({ roles: ['admin'] }));\n      }),\n      // Mock successful deletion\n      rest.delete(`${API_BASE_URL}/products/${productId}`, (req, res, ctx) => {\n        return res(ctx.status(204));\n      })\n    );\n\n    renderWithRouter(<ProductDetailPage />, { route: `/products/${productId}` });\n\n    await waitFor(() => expect(screen.getByRole('button', { name: /Delete Product/i })).toBeInTheDocument());\n\n    await userEvent.click(screen.getByRole('button', { name: /Delete Product/i }));\n\n    // Expect confirmation dialog (if implemented)\n    // await userEvent.click(screen.getByRole('button', { name: /Confirm Delete/i }));\n\n    // Expect navigation away from the detail page on successful delete\n    await waitFor(() => expect(screen.getByText(/Product List Page/i)).toBeInTheDocument());\n    expect(screen.queryByText(`Product Details: ${productName}`)).not.toBeInTheDocument();\n  });\n\n  it('should show an error message if product deletion fails', async () => {\n    // Mock user permissions to be admin\n    server.use(\n      rest.get(`${API_BASE_URL}/user/permissions`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json({ roles: ['admin'] }));\n      }),\n      // Mock failed deletion\n      rest.delete(`${API_BASE_URL}/products/${productId}`, (req, res, ctx) => {\n        return res(ctx.status(500), ctx.json({ message: 'Internal server error' }));\n      })\n    );\n\n    renderWithRouter(<ProductDetailPage />, { route: `/products/${productId}` });\n\n    await waitFor(() => expect(screen.getByRole('button', { name: /Delete Product/i })).toBeInTheDocument());\n\n    await userEvent.click(screen.getByRole('button', { name: /Delete Product/i }));\n\n    await waitFor(() => expect(screen.getByText(/Failed to delete product\\. Please try again\\./i)).toBeInTheDocument());\n    // Ensure we are still on the product detail page\n    expect(screen.getByText(`Product Details: ${productName}`)).toBeInTheDocument();\n  });\n});\n```\n\n#### Category 4: Data Aggregation and Dynamic UI Updates\n\n**Scenario 4.1: Dashboard Analytics - Total Active Products**\n*   **Description:** A dashboard component displays a count of \"Active Products\". This count is derived by filtering a list of products fetched from the API based on their `status` field.\n*   **API Endpoint:** `GET /products?status=available`\n*   **Expected Behavior:**\n    1.  The dashboard fetches products.\n    2.  Only products with `status: 'available'` are counted.\n    3.  The correct total count is displayed prominently.\n*   **Test Steps:**\n    1.  Mock `GET /products?status=available` to return a specific list of available products.\n    2.  Mock `GET /products` for the full list if the dashboard also displays it.\n    3.  Render the `Dashboard` component.\n    4.  Wait for the count to be displayed.\n    5.  Assert that the displayed count matches the expected number of available products from the mock.\n\n**Test Example (DashboardPage.test.js):**\n```javascript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport { server } from '../mocks/server';\nimport { rest } from 'msw';\nimport DashboardPage from '../components/DashboardPage'; // Assume this component exists\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\ndescribe('DashboardPage - Custom Analytics', () => {\n  it('should display the correct count of active products', async () => {\n    // Mock the API for active products\n    server.use(\n      rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        const statusFilter = req.url.searchParams.get('status');\n        if (statusFilter === 'available') {\n          return res(\n            ctx.status(200),\n            ctx.json([\n              { id: 'p1', name: 'Laptop Pro', status: 'available' },\n              { id: 'p3', name: 'Wireless Mouse', status: 'available' },\n            ])\n          );\n        }\n        return res(ctx.status(200), ctx.json([])); // Default for other filters\n      })\n    );\n\n    render(<DashboardPage />);\n\n    // Wait for the active products count to be displayed\n    await waitFor(() => {\n      expect(screen.getByText(/Total Active Products: 2/i)).toBeInTheDocument();\n    });\n\n    // Optionally, if the dashboard also lists them\n    expect(screen.getByText(/Laptop Pro/i)).toBeInTheDocument();\n    expect(screen.getByText(/Wireless Mouse/i)).toBeInTheDocument();\n  });\n\n  it('should display 0 active products when no available products are returned', async () => {\n    server.use(\n      rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        const statusFilter = req.url.searchParams.get('status');\n        if (statusFilter === 'available') {\n          return res(ctx.status(200), ctx.json([]));\n        }\n        return res(ctx.status(200), ctx.json([]));\n      })\n    );\n\n    render(<DashboardPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText(/Total Active Products: 0/i)).toBeInTheDocument();\n    });\n  });\n});\n```\n\n### 7. Maintenance and Evolution\n*   **Regular Review:** Periodically review these custom tests to ensure they still reflect current business logic and API contracts.\n*   **Update Mocks:** As API payloads or endpoints change, update `msw` handlers accordingly.\n*   **Expand Coverage:** As new complex features or critical user flows are introduced, add new custom test cases.\n*   **Refactor:** Keep tests clean and readable. Use helper functions for common rendering setups or assertions.\n*   **CI/CD Integration:** Ensure these tests run as part of your Continuous Integration pipeline to catch regressions early.\n\n---\n\nThis framework for \"Custom API Frontend Tests\" provides a robust way to ensure the frontend application's stability and correctness when interacting with backend services, particularly for unique business requirements and complex user interactions.",
    "metadata": {
      "model_used": "gemini-2.5-flash",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_1c1e13c2",
      "attempts": [
        {
          "model": "gemini-2.5-flash",
          "provider": "gemini",
          "content": "As an expert architect and developer assistant, I understand the critical importance of robust frontend testing, especially when integrating with APIs. This document outlines a strategy and provides examples for generating **Custom API Frontend Tests**, focusing on scenarios beyond basic component rendering, ensuring your application behaves correctly under specific business logic, complex data flows, and various API interaction patterns.\n\n---\n\n## API Frontend Test Strategy: Custom Scenarios\n\n### 1. Document Title\n**Custom API Frontend Test Suite: Product Management Dashboard**\n\n### 2. Introduction\nThis document defines a custom test suite for a frontend application, specifically targeting its interaction with backend APIs. The goal is to go beyond generic unit tests by focusing on end-to-end user flows, complex data transformations, error handling, and specific business logic that relies on API responses. These tests simulate real-world user interactions and various API states to ensure the frontend behaves as expected, providing a reliable and consistent user experience.\n\n**Target Application Example:** A \"Product Management Dashboard\" allowing users to view, create, edit, and delete products, manage inventory, and view analytics.\n\n### 3. Key Principles & Best Practices for Custom Tests\n\n*   **Focus on User Journeys:** Test complete user flows, not just isolated components.\n*   **Mock API Responses Realistically:** Use tools like `msw` (Mock Service Worker) to intercept network requests and return controlled, realistic API responses (success, error, loading states). Avoid direct mocking of `fetch` or `axios` globally, as it can be brittle.\n*   **Test Asynchronous Operations:** Ensure proper handling of loading states, data fetching, and race conditions.\n*   **Isolate Frontend Logic:** While testing API integration, aim to keep the tests focused on the frontend's reaction to API responses, not on validating the backend itself.\n*   **Prioritize Critical Paths:** Focus custom tests on the most important user flows and core business functionalities.\n*   **Clear, Descriptive Test Names:** Names should explain *what* is being tested and *why*.\n*   **Cleanup Between Tests:** Ensure each test starts with a clean slate to prevent side effects.\n*   **Leverage Testing Libraries:** Use tools like `@testing-library/react` (for React) or similar for other frameworks, which encourage testing user-facing behavior rather than implementation details.\n\n### 4. Assumptions\n*   **Frontend Framework:** React (examples will use `react-testing-library` and `jest`).\n*   **API Mocking Library:** `msw` (Mock Service Worker) for intercepting network requests.\n*   **Styling:** CSS Modules or Styled Components (not directly tested, but assumes existence).\n*   **Routing:** React Router (or equivalent).\n*   **State Management:** Context API, Redux, Zustand, or similar is used (tests will interact with the UI, abstracting the specific implementation).\n*   **Development Server:** A local development environment is running where the frontend can be rendered.\n\n### 5. Test Environment & Tools (Example Setup)\n\n*   **Test Runner:** Jest\n*   **DOM Testing Library:** `@testing-library/react`\n*   **API Mocking:** `msw` (Mock Service Worker)\n*   **Assertion Library:** Jest's built-in matchers\n*   **Utility Libraries:** `@testing-library/user-event` (for simulating user interactions)\n\n**`src/mocks/handlers.js` (MSW Request Handlers):**\n```javascript\nimport { rest } from 'msw';\n\nconst API_BASE_URL = 'http://localhost:3001/api'; // Or your actual API base URL\n\nexport const handlers = [\n  // Products API\n  rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n    const statusFilter = req.url.searchParams.get('status');\n    let products = [\n      { id: 'p1', name: 'Laptop Pro', price: 1200, stock: 50, status: 'available' },\n      { id: 'p2', name: 'Mechanical Keyboard', price: 150, stock: 0, status: 'out_of_stock' },\n      { id: 'p3', name: 'Wireless Mouse', price: 75, stock: 120, status: 'available' },\n      { id: 'p4', name: 'Webcam HD', price: 100, stock: 10, status: 'low_stock' },\n    ];\n\n    if (statusFilter) {\n      products = products.filter(p => p.status === statusFilter);\n    }\n\n    return res(\n      ctx.status(200),\n      ctx.json(products)\n    );\n  }),\n\n  rest.get(`${API_BASE_URL}/products/:id`, (req, res, ctx) => {\n    const { id } = req.params;\n    const product = { id: id, name: `Product ${id}`, price: 100, stock: 10, status: 'available' };\n    if (id === 'p1') {\n      return res(ctx.status(200), ctx.json({ id: 'p1', name: 'Laptop Pro', price: 1200, stock: 50, status: 'available' }));\n    }\n    if (id === 'p_nonexistent') {\n      return res(ctx.status(404), ctx.json({ message: 'Product not found' }));\n    }\n    return res(ctx.status(200), ctx.json(product));\n  }),\n\n  rest.post(`${API_BASE_URL}/products`, (req, res, ctx) => {\n    const { name, price, stock, status } = req.body;\n    if (!name || !price || !stock) {\n      return res(ctx.status(400), ctx.json({ message: 'Missing required fields' }));\n    }\n    return res(\n      ctx.status(201),\n      ctx.json({ id: 'new-product-id', name, price, stock, status: status || 'available' })\n    );\n    // return res(ctx.status(500), ctx.json({ message: 'Failed to create product' })); // Example error response\n  }),\n\n  rest.put(`${API_BASE_URL}/products/:id`, (req, res, ctx) => {\n    const { id } = req.params;\n    const { name, price, stock, status } = req.body;\n    if (id === 'p_forbidden') {\n      return res(ctx.status(403), ctx.json({ message: 'Permission denied' }));\n    }\n    return res(\n      ctx.status(200),\n      ctx.json({ id, name, price, stock, status })\n    );\n  }),\n\n  rest.delete(`${API_BASE_URL}/products/:id`, (req, res, ctx) => {\n    const { id } = req.params;\n    if (id === 'p_error_delete') {\n      return res(ctx.status(500), ctx.json({ message: 'Internal server error during deletion' }));\n    }\n    return res(ctx.status(204)); // No content for successful deletion\n  }),\n\n  // User/Auth API (for permissions example)\n  rest.get(`${API_BASE_URL}/user/permissions`, (req, res, ctx) => {\n    return res(\n      ctx.status(200),\n      ctx.json({ roles: ['viewer', 'editor'] })\n    );\n  }),\n  // ... other API handlers\n];\n```\n**`src/setupTests.js` (Jest Setup File):**\n```javascript\nimport '@testing-library/jest-dom';\nimport { server } from './mocks/server.js';\n\n// Establish API mocking before all tests.\nbeforeAll(() => server.listen());\n\n// Reset any request handlers that we may add during the tests,\n// so they don't affect other tests.\nafterEach(() => server.resetHandlers());\n\n// Clean up after the tests are finished.\nafterAll(() => server.close());\n```\n\n### 6. Custom API Frontend Test Cases\n\n#### Category 1: Complex Data Fetching & Conditional Display\n\n**Scenario 1.1: Displaying Product List with Status Indicators**\n*   **Description:** When fetching a list of products, the frontend should correctly display product details and apply distinct visual styles (e.g., greyed out, \"Out of Stock\" badge) based on their `status` or `stock` quantity received from the API.\n*   **API Endpoint:** `GET /products`\n*   **Expected Behavior:**\n    *   Products with `status: 'available'` should appear normally.\n    *   Products with `status: 'out_of_stock'` should be visually distinct (e.g., greyed out, show \"Out of Stock\" label).\n    *   Products with `status: 'low_stock'` should show a warning indicator (e.g., \"Low Stock\" label).\n*   **Test Steps:**\n    1.  Mock `GET /products` to return a mix of 'available', 'out_of_stock', and 'low_stock' products.\n    2.  Render the `ProductListPage` component.\n    3.  Wait for products to load.\n    4.  Assert that the 'available' product is displayed normally.\n    5.  Assert that the 'out_of_stock' product is greyed out or shows an \"Out of Stock\" label.\n    6.  Assert that the 'low_stock' product shows a \"Low Stock\" warning.\n\n**Test Example (ProductListPage.test.js):**\n```javascript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport { server } from '../mocks/server';\nimport { rest } from 'msw';\nimport ProductListPage from '../components/ProductListPage'; // Assume this component exists\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\ndescribe('ProductListPage - Custom Data Display', () => {\n  it('should display products with correct status indicators', async () => {\n    // Custom mock for this specific test case\n    server.use(\n      rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        return res(\n          ctx.status(200),\n          ctx.json([\n            { id: 'p1', name: 'Laptop Pro', price: 1200, stock: 50, status: 'available' },\n            { id: 'p2', name: 'Mechanical Keyboard', price: 150, stock: 0, status: 'out_of_stock' },\n            { id: 'p3', name: 'Wireless Mouse', price: 75, stock: 10, status: 'low_stock' },\n          ])\n        );\n      })\n    );\n\n    render(<ProductListPage />);\n\n    // Check loading state first\n    expect(screen.getByText(/Loading products.../i)).toBeInTheDocument();\n\n    // Wait for the products to appear\n    await waitFor(() => expect(screen.getByText(/Laptop Pro/i)).toBeInTheDocument());\n\n    // Assert status indicators\n    const laptopPro = screen.getByText(/Laptop Pro/i);\n    expect(laptopPro).toBeInTheDocument();\n    expect(laptopPro).not.toHaveClass('product-out-of-stock'); // Assuming CSS class for styling\n\n    const mechanicalKeyboard = screen.getByText(/Mechanical Keyboard/i);\n    expect(mechanicalKeyboard).toBeInTheDocument();\n    // Assuming a specific text or role for 'out of stock' indicator\n    expect(screen.getByText(/Out of Stock/i)).toBeInTheDocument();\n    // expect(mechanicalKeyboard).toHaveClass('product-out-of-stock'); // If visual style is applied directly\n\n    const wirelessMouse = screen.getByText(/Wireless Mouse/i);\n    expect(wirelessMouse).toBeInTheDocument();\n    // Assuming a specific text for 'low stock' indicator\n    expect(screen.getByText(/Low Stock \\(10\\)/i)).toBeInTheDocument();\n  });\n\n  it('should display an empty state message when no products are returned', async () => {\n    server.use(\n      rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json([]));\n      })\n    );\n\n    render(<ProductListPage />);\n    await waitFor(() => expect(screen.getByText(/No products found/i)).toBeInTheDocument());\n    expect(screen.queryByText(/Laptop Pro/i)).not.toBeInTheDocument(); // Ensure no products are rendered\n  });\n});\n```\n\n#### Category 2: Multi-Step Workflow with API Dependencies\n\n**Scenario 2.1: Create Product & Immediately View Details (Post-redirect/Post-success Fetch)**\n*   **Description:** A user creates a new product, and upon successful creation, the frontend navigates to the detail page of the newly created product. This involves a `POST` request followed by a `GET` request.\n*   **API Endpoints:** `POST /products`, `GET /products/:id`\n*   **Expected Behavior:**\n    1.  User fills out the form and submits.\n    2.  `POST /products` is called.\n    3.  On success, the frontend redirects to `/products/:newProductId`.\n    4.  A `GET /products/:newProductId` request is made.\n    5.  The details of the newly created product are displayed.\n*   **Test Steps:**\n    1.  Mock `POST /products` to return a success response with a `newProductId`.\n    2.  Mock `GET /products/:newProductId` to return the details of the newly created product.\n    3.  Render the `CreateProductPage` component.\n    4.  Fill the form fields.\n    5.  Click the \"Create Product\" button.\n    6.  Assert that the loading state is shown.\n    7.  Assert that the `GET /products/:newProductId` request is made (e.g., by waiting for its content to appear).\n    8.  Assert that the `ProductDetailPage` for the new product is rendered with the correct data.\n\n**Test Example (CreateProductPage.test.js):**\n```javascript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { server } from '../mocks/server';\nimport { rest } from 'msw';\nimport { MemoryRouter, Route, Routes } from 'react-router-dom'; // For routing context\nimport CreateProductPage from '../components/CreateProductPage';\nimport ProductDetailPage from '../components/ProductDetailPage'; // Assuming this component exists\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\ndescribe('CreateProductPage - Multi-step Workflow', () => {\n  it('should create a product and navigate to its detail page', async () => {\n    const newProductId = 'prod-xyz-123';\n    const newProductName = 'New Super Gadget';\n    const newProductPrice = 99.99;\n    const newProductStock = 500;\n\n    // Mock the POST request for creating a product\n    server.use(\n      rest.post(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        return res(\n          ctx.status(201),\n          ctx.json({ id: newProductId, name: newProductName, price: newProductPrice, stock: newProductStock, status: 'available' })\n        );\n      }),\n      // Mock the GET request for fetching the newly created product's details\n      rest.get(`${API_BASE_URL}/products/${newProductId}`, (req, res, ctx) => {\n        return res(\n          ctx.status(200),\n          ctx.json({ id: newProductId, name: newProductName, price: newProductPrice, stock: newProductStock, status: 'available' })\n        );\n      })\n    );\n\n    render(\n      <MemoryRouter initialEntries={['/products/create']}>\n        <Routes>\n          <Route path=\"/products/create\" element={<CreateProductPage />} />\n          <Route path=\"/products/:id\" element={<ProductDetailPage />} />\n        </Routes>\n      </MemoryRouter>\n    );\n\n    // Fill the form\n    await userEvent.type(screen.getByLabelText(/Product Name/i), newProductName);\n    await userEvent.type(screen.getByLabelText(/Price/i), newProductPrice.toString());\n    await userEvent.type(screen.getByLabelText(/Stock/i), newProductStock.toString());\n\n    // Click the create button\n    await userEvent.click(screen.getByRole('button', { name: /Create Product/i }));\n\n    // Expect navigation and details of the new product to be displayed\n    await waitFor(() => {\n      expect(screen.getByText(`Product Details: ${newProductName}`)).toBeInTheDocument();\n      expect(screen.getByText(`Price: $${newProductPrice}`)).toBeInTheDocument();\n      expect(screen.getByText(`Stock: ${newProductStock}`)).toBeInTheDocument();\n    });\n\n    // Ensure the create form is no longer visible\n    expect(screen.queryByLabelText(/Product Name/i)).not.toBeInTheDocument();\n  });\n});\n```\n\n#### Category 3: Error Handling & Permission-Based UI\n\n**Scenario 3.1: \"Delete Product\" Button - Permissions & API Error**\n*   **Description:** The \"Delete Product\" button should only be visible and enabled for users with 'admin' permissions. If an admin tries to delete a product and the API returns an error, a user-friendly error message should be displayed.\n*   **API Endpoints:** `GET /user/permissions` (or JWT check), `DELETE /products/:id`\n*   **Expected Behavior:**\n    1.  If user is not 'admin', the delete button is not visible or disabled.\n    2.  If user is 'admin', the delete button is visible and enabled.\n    3.  If `DELETE /products/:id` fails (e.g., 500 status), an error message (e.g., \"Failed to delete product. Please try again.\") appears.\n    4.  If `DELETE /products/:id` succeeds, the product is removed from the list, and a success message appears.\n*   **Test Steps:**\n    1.  **Test 1 (No Permissions):** Mock `GET /user/permissions` to return non-admin roles. Render `ProductDetailPage`. Assert delete button is absent/disabled.\n    2.  **Test 2 (With Permissions, Delete Success):** Mock `GET /user/permissions` to return admin roles. Mock `DELETE /products/:id` to succeed (204). Render `ProductDetailPage`. Click delete. Assert success message and product removal.\n    3.  **Test 3 (With Permissions, Delete Failure):** Mock `GET /user/permissions` to return admin roles. Mock `DELETE /products/:id` to fail (500). Render `ProductDetailPage`. Click delete. Assert error message.\n\n**Test Example (ProductDetailPage.test.js):**\n```javascript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { server } from '../mocks/server';\nimport { rest } from 'msw';\nimport { MemoryRouter, Route, Routes } from 'react-router-dom';\nimport ProductDetailPage from '../components/ProductDetailPage';\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\n// Helper to render the component with routing context\nconst renderWithRouter = (ui, { route = '/' } = {}) => {\n  window.history.pushState({}, 'Test page', route);\n  return render(\n    <MemoryRouter initialEntries={[route]}>\n      <Routes>\n        <Route path=\"/products/:id\" element={ui} />\n        <Route path=\"/products\" element={<div>Product List Page (Redirect Target)</div>} />\n      </Routes>\n    </MemoryRouter>\n  );\n};\n\ndescribe('ProductDetailPage - Custom Permissions & Error Handling', () => {\n  const productId = 'p1';\n  const productName = 'Laptop Pro';\n\n  beforeEach(() => {\n    // Default product fetch mock for the detail page\n    server.use(\n      rest.get(`${API_BASE_URL}/products/${productId}`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json({ id: productId, name: productName, price: 1200, stock: 50, status: 'available' }));\n      })\n    );\n  });\n\n  it('should hide the delete button for non-admin users', async () => {\n    // Mock user permissions to be non-admin\n    server.use(\n      rest.get(`${API_BASE_URL}/user/permissions`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json({ roles: ['viewer'] })); // No admin role\n      })\n    );\n\n    renderWithRouter(<ProductDetailPage />, { route: `/products/${productId}` });\n\n    await waitFor(() => expect(screen.getByText(`Product Details: ${productName}`)).toBeInTheDocument());\n\n    expect(screen.queryByRole('button', { name: /Delete Product/i })).not.toBeInTheDocument();\n  });\n\n  it('should display and allow deletion for admin users', async () => {\n    // Mock user permissions to be admin\n    server.use(\n      rest.get(`${API_BASE_URL}/user/permissions`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json({ roles: ['admin'] }));\n      }),\n      // Mock successful deletion\n      rest.delete(`${API_BASE_URL}/products/${productId}`, (req, res, ctx) => {\n        return res(ctx.status(204));\n      })\n    );\n\n    renderWithRouter(<ProductDetailPage />, { route: `/products/${productId}` });\n\n    await waitFor(() => expect(screen.getByRole('button', { name: /Delete Product/i })).toBeInTheDocument());\n\n    await userEvent.click(screen.getByRole('button', { name: /Delete Product/i }));\n\n    // Expect confirmation dialog (if implemented)\n    // await userEvent.click(screen.getByRole('button', { name: /Confirm Delete/i }));\n\n    // Expect navigation away from the detail page on successful delete\n    await waitFor(() => expect(screen.getByText(/Product List Page/i)).toBeInTheDocument());\n    expect(screen.queryByText(`Product Details: ${productName}`)).not.toBeInTheDocument();\n  });\n\n  it('should show an error message if product deletion fails', async () => {\n    // Mock user permissions to be admin\n    server.use(\n      rest.get(`${API_BASE_URL}/user/permissions`, (req, res, ctx) => {\n        return res(ctx.status(200), ctx.json({ roles: ['admin'] }));\n      }),\n      // Mock failed deletion\n      rest.delete(`${API_BASE_URL}/products/${productId}`, (req, res, ctx) => {\n        return res(ctx.status(500), ctx.json({ message: 'Internal server error' }));\n      })\n    );\n\n    renderWithRouter(<ProductDetailPage />, { route: `/products/${productId}` });\n\n    await waitFor(() => expect(screen.getByRole('button', { name: /Delete Product/i })).toBeInTheDocument());\n\n    await userEvent.click(screen.getByRole('button', { name: /Delete Product/i }));\n\n    await waitFor(() => expect(screen.getByText(/Failed to delete product\\. Please try again\\./i)).toBeInTheDocument());\n    // Ensure we are still on the product detail page\n    expect(screen.getByText(`Product Details: ${productName}`)).toBeInTheDocument();\n  });\n});\n```\n\n#### Category 4: Data Aggregation and Dynamic UI Updates\n\n**Scenario 4.1: Dashboard Analytics - Total Active Products**\n*   **Description:** A dashboard component displays a count of \"Active Products\". This count is derived by filtering a list of products fetched from the API based on their `status` field.\n*   **API Endpoint:** `GET /products?status=available`\n*   **Expected Behavior:**\n    1.  The dashboard fetches products.\n    2.  Only products with `status: 'available'` are counted.\n    3.  The correct total count is displayed prominently.\n*   **Test Steps:**\n    1.  Mock `GET /products?status=available` to return a specific list of available products.\n    2.  Mock `GET /products` for the full list if the dashboard also displays it.\n    3.  Render the `Dashboard` component.\n    4.  Wait for the count to be displayed.\n    5.  Assert that the displayed count matches the expected number of available products from the mock.\n\n**Test Example (DashboardPage.test.js):**\n```javascript\nimport { render, screen, waitFor } from '@testing-library/react';\nimport { server } from '../mocks/server';\nimport { rest } from 'msw';\nimport DashboardPage from '../components/DashboardPage'; // Assume this component exists\n\nconst API_BASE_URL = 'http://localhost:3001/api';\n\ndescribe('DashboardPage - Custom Analytics', () => {\n  it('should display the correct count of active products', async () => {\n    // Mock the API for active products\n    server.use(\n      rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        const statusFilter = req.url.searchParams.get('status');\n        if (statusFilter === 'available') {\n          return res(\n            ctx.status(200),\n            ctx.json([\n              { id: 'p1', name: 'Laptop Pro', status: 'available' },\n              { id: 'p3', name: 'Wireless Mouse', status: 'available' },\n            ])\n          );\n        }\n        return res(ctx.status(200), ctx.json([])); // Default for other filters\n      })\n    );\n\n    render(<DashboardPage />);\n\n    // Wait for the active products count to be displayed\n    await waitFor(() => {\n      expect(screen.getByText(/Total Active Products: 2/i)).toBeInTheDocument();\n    });\n\n    // Optionally, if the dashboard also lists them\n    expect(screen.getByText(/Laptop Pro/i)).toBeInTheDocument();\n    expect(screen.getByText(/Wireless Mouse/i)).toBeInTheDocument();\n  });\n\n  it('should display 0 active products when no available products are returned', async () => {\n    server.use(\n      rest.get(`${API_BASE_URL}/products`, (req, res, ctx) => {\n        const statusFilter = req.url.searchParams.get('status');\n        if (statusFilter === 'available') {\n          return res(ctx.status(200), ctx.json([]));\n        }\n        return res(ctx.status(200), ctx.json([]));\n      })\n    );\n\n    render(<DashboardPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText(/Total Active Products: 0/i)).toBeInTheDocument();\n    });\n  });\n});\n```\n\n### 7. Maintenance and Evolution\n*   **Regular Review:** Periodically review these custom tests to ensure they still reflect current business logic and API contracts.\n*   **Update Mocks:** As API payloads or endpoints change, update `msw` handlers accordingly.\n*   **Expand Coverage:** As new complex features or critical user flows are introduced, add new custom test cases.\n*   **Refactor:** Keep tests clean and readable. Use helper functions for common rendering setups or assertions.\n*   **CI/CD Integration:** Ensure these tests run as part of your Continuous Integration pipeline to catch regressions early.\n\n---\n\nThis framework for \"Custom API Frontend Tests\" provides a robust way to ensure the frontend application's stability and correctness when interacting with backend services, particularly for unique business requirements and complex user interactions.",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='2576034875600'>"
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T23:13:02.311666",
    "is_current": false
  },
  {
    "version": 11,
    "artifact_id": "api_frontend_test_custom",
    "artifact_type": "api_frontend_test_custom",
    "content": "As an expert architect and developer assistant, I understand the need for robust and custom frontend tests to ensure seamless integration with backend APIs. While the provided requirement \"Test\" is concise, it implies a need for a foundational and illustrative example of how to approach API-dependent frontend testing.\n\nBelow, I've generated a comprehensive \"API Frontend Test Custom\" example. This example focuses on common scenarios for a component that fetches and displays data, using popular tools like React Testing Library and Jest for demonstration.\n\n---\n\n## API Frontend Test Custom: Product List Component\n\nThis custom test suite demonstrates how to effectively test a frontend component that interacts with a backend API to fetch and display data. It covers success cases, loading states, empty states, and error handling, ensuring a resilient user experience.\n\n### 1. Purpose & Importance of API Frontend Tests\n\nFrontend tests that interact with APIs are crucial for:\n*   **Verifying Integration:** Ensuring the frontend correctly calls the API, handles responses, and displays data as expected.\n*   **User Experience (UX) Validation:** Testing loading states, error messages, and empty data scenarios to confirm the user receives appropriate feedback.\n*   **Isolation from Backend:** Using mocks to isolate the frontend from the actual backend, making tests faster, more reliable, and independent of backend availability.\n*   **Regression Prevention:** Catching regressions early when API contracts or frontend logic changes.\n*   **Maintainability:** Providing clear examples of expected behavior for future developers.\n\n### 2. Assumptions & Technology Stack\n\n*   **Frontend Framework:** React (using functional components and `useEffect`).\n*   **Testing Framework:** Jest.\n*   **Testing Utilities:** React Testing Library (RTL) for rendering components and interacting with them in a user-centric way.\n*   **API Mocking:** `jest.spyOn(global, 'fetch')` for mocking the native `fetch` API. For more complex scenarios, libraries like `msw` (Mock Service Worker) or `jest-fetch-mock` are often used.\n*   **API Endpoint:** `/api/products` (GET request).\n*   **Scenario:** A `ProductList` component fetches a list of products and displays them.\n\n### 3. Frontend Component (`ProductList.js`)\n\nFirst, let's define the simplified React component we'll be testing.\n\n```javascript\n// src/components/ProductList.js\nimport React, { useEffect, useState } from 'react';\n\nconst ProductList = () => {\n  const [products, setProducts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchProducts = async () => {\n      try {\n        const response = await fetch('/api/products');\n        if (!response.ok) {\n          // Handle non-2xx HTTP responses as errors\n          throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);\n        }\n        const data = await response.json();\n        setProducts(data);\n      } catch (e) {\n        // Handle network errors or issues parsing JSON\n        setError('Failed to fetch products. Please try again later.');\n        console.error('Error fetching products:', e);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchProducts();\n  }, []); // Empty dependency array means this runs once on mount\n\n  if (loading) {\n    return <div data-testid=\"loading-message\">Loading products...</div>;\n  }\n\n  if (error) {\n    return <div data-testid=\"error-message\">{error}</div>;\n  }\n\n  if (products.length === 0) {\n    return <div data-testid=\"no-products-message\">No products found.</div>;\n  }\n\n  return (\n    <div>\n      <h1>Product List</h1>\n      <ul data-testid=\"product-list\">\n        {products.map((product) => (\n          <li key={product.id}>{product.name} - ${product.price.toFixed(2)}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default ProductList;\n```\n\n### 4. API Frontend Test (`ProductList.test.js`)\n\nThis test file will mock the `fetch` API and use React Testing Library to render and interact with the `ProductList` component, asserting its behavior under different API responses.\n\n```javascript\n// src/components/ProductList.test.js\nimport { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom'; // For extended matchers like .toBeInTheDocument()\nimport ProductList from './ProductList';\n\ndescribe('ProductList - API Frontend Test', () => {\n  // Use a variable to hold the mock fetch function\n  let mockFetch;\n\n  // beforeEach: Set up mocks before each test\n  beforeEach(() => {\n    // Spy on the global fetch function and replace it with a Jest mock function\n    mockFetch = jest.spyOn(global, 'fetch');\n  });\n\n  // afterEach: Clean up mocks after each test to ensure test isolation\n  afterEach(() => {\n    // Restore the original fetch implementation after each test\n    mockFetch.mockRestore();\n  });\n\n  // --- Test Case 1: Successful API fetch and data display ---\n  it('should display loading state initially, then products upon successful fetch', async () => {\n    // 1. Arrange: Define the mock API response for successful data\n    const mockProducts = [\n      { id: 1, name: 'Laptop', price: 1200.00 },\n      { id: 2, name: 'Wireless Mouse', price: 25.50 },\n      { id: 3, name: 'Keyboard', price: 75.00 },\n    ];\n\n    // Configure the mock fetch to resolve with our mock data\n    mockFetch.mockResolvedValueOnce({\n      ok: true, // Simulate a successful HTTP response (status 2xx)\n      json: () => Promise.resolve(mockProducts), // Return the mock JSON data\n      status: 200,\n      statusText: 'OK',\n    });\n\n    // 2. Act: Render the component\n    render(<ProductList />);\n\n    // 3. Assert (Initial State): Check for the loading message\n    expect(screen.getByTestId('loading-message')).toBeInTheDocument();\n    expect(screen.getByText('Loading products...')).toBeInTheDocument();\n\n    // 4. Assert (After API Call): Wait for the asynchronous update and check for products\n    // `waitFor` is essential for async operations in React Testing Library\n    await waitFor(() => {\n      // Ensure the loading message is gone\n      expect(screen.queryByTestId('loading-message')).not.toBeInTheDocument();\n      expect(screen.queryByText('Loading products...')).not.toBeInTheDocument();\n    });\n\n    // Check if the product list title and individual products are displayed\n    expect(screen.getByRole('heading', { name: /product list/i })).toBeInTheDocument();\n    expect(screen.getByTestId('product-list')).toBeInTheDocument();\n    expect(screen.getByText('Laptop - $1200.00')).toBeInTheDocument();\n    expect(screen.getByText('Wireless Mouse - $25.50')).toBeInTheDocument();\n    expect(screen.getByText('Keyboard - $75.00')).toBeInTheDocument();\n\n    // Verify the number of list items rendered\n    expect(screen.getAllByRole('listitem')).toHaveLength(mockProducts.length);\n\n    // Ensure fetch was called correctly\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n    expect(mockFetch).toHaveBeenCalledWith('/api/products');\n  });\n\n  // --- Test Case 2: API returns an empty array (no products) ---\n  it('should display \"No products found.\" if the API returns an empty array', async () => {\n    // 1. Arrange: Mock API to return an empty array\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve([]), // Simulate an empty product list\n      status: 200,\n      statusText: 'OK',\n    });\n\n    // 2. Act: Render the component\n    render(<ProductList />);\n\n    // 3. Assert: Wait for the component to update and check for the \"No products found.\" message\n    await waitFor(() => {\n      expect(screen.getByTestId('no-products-message')).toBeInTheDocument();\n      expect(screen.getByText('No products found.')).toBeInTheDocument();\n    });\n\n    // Ensure loading state is gone and no product list is rendered\n    expect(screen.queryByTestId('loading-message')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('product-list')).not.toBeInTheDocument();\n  });\n\n  // --- Test Case 3: API fetch fails (network error or bad HTTP status) ---\n  it('should display an error message if the API fetch fails', async () => {\n    // 1. Arrange: Mock API to simulate a network error or a non-OK HTTP response\n\n    // Option A: Simulate a network error (e.g., disconnected, CORS issue)\n    mockFetch.mockRejectedValueOnce(new Error('Failed to connect to network'));\n\n    // Option B: Simulate a server error (e.g., 500 Internal Server Error)\n    // mockFetch.mockResolvedValueOnce({\n    //   ok: false, // Indicate a non-successful HTTP response\n    //   status: 500,\n    //   statusText: 'Internal Server Error',\n    //   json: () => Promise.resolve({ message: 'Server error occurred' }), // Optional: if API sends an error body\n    // });\n\n    // 2. Act: Render the component\n    render(<ProductList />);\n\n    // 3. Assert: Wait for the error message to appear\n    await waitFor(() => {\n      expect(screen.getByTestId('error-message')).toBeInTheDocument();\n      expect(screen.getByText('Failed to fetch products. Please try again later.')).toBeInTheDocument();\n    });\n\n    // Ensure loading state is gone and no product list is rendered\n    expect(screen.queryByTestId('loading-message')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('product-list')).not.toBeInTheDocument();\n    expect(screen.queryByText('No products found.')).not.toBeInTheDocument();\n  });\n});\n```\n\n### 5. Best Practices & Considerations\n\n*   **User-Centric Testing (RTL):** React Testing Library encourages testing components the way a user would interact with them. Avoid testing internal state directly; focus on what the user sees and does.\n*   **Mocking Strategy:**\n    *   For simple `fetch` calls, `jest.spyOn(global, 'fetch')` is often sufficient.\n    *   For more complex APIs, multiple endpoints, or if you want to reuse mocks across different tests or even stories, consider using **Mock Service Worker (MSW)**. MSW intercepts network requests at the service worker level, allowing you to define powerful, persistent, and realistic API mocks that work across different testing environments (Jest, Cypress, Storybook, etc.).\n    *   `jest-fetch-mock` is another option specific to Jest for mocking `fetch`.\n*   **Test Data Management:** Use realistic but minimal mock data. For larger applications, consider factories or fixtures to generate test data.\n*   **Async Handling (`waitFor`):** Always use `await waitFor()` or `findBy*` queries from RTL when asserting against changes that happen after an asynchronous operation (like an API call). This prevents race conditions in your tests.\n*   **Clean Up Mocks:** Always `mockRestore()` or `resetHandlers()` (for MSW) after each test to ensure test isolation and prevent side effects from leaking between tests.\n*   **Error Boundaries:** For real applications, consider adding React Error Boundaries to gracefully catch rendering errors in child components. Test how your components behave when an error boundary catches an issue during data rendering.\n*   **Accessibility:** Use semantic HTML and `data-testid` attributes sparingly. Prioritize queries like `getByRole`, `getByText`, `getByLabelText`, which promote accessible code.\n*   **Edge Cases:** Beyond success and error, consider:\n    *   Very large datasets.\n    *   Pagination scenarios.\n    *   Rate limiting responses.\n    *   Authentication failures (401/403).\n    *   Timeouts.\n\nThis custom test suite provides a robust foundation for testing frontend components that interact with APIs, ensuring a high-quality and reliable application.",
    "metadata": {
      "model_used": "gemini-2.5-flash",
      "provider": "cloud",
      "validation_score": 95.0,
      "is_valid": true,
      "meeting_notes": "Custom notes",
      "html_content": null,
      "quality_prediction": {
        "label": "low",
        "confidence": 0.30000000000000004,
        "score": 0.30000000000000004,
        "reasons": {
          "notes_depth": -0.15,
          "context_rag": -0.1
        }
      },
      "job_id": "gen_8afe75f0",
      "attempts": [
        {
          "model": "gemini-2.5-flash",
          "provider": "gemini",
          "content": "As an expert architect and developer assistant, I understand the need for robust and custom frontend tests to ensure seamless integration with backend APIs. While the provided requirement \"Test\" is concise, it implies a need for a foundational and illustrative example of how to approach API-dependent frontend testing.\n\nBelow, I've generated a comprehensive \"API Frontend Test Custom\" example. This example focuses on common scenarios for a component that fetches and displays data, using popular tools like React Testing Library and Jest for demonstration.\n\n---\n\n## API Frontend Test Custom: Product List Component\n\nThis custom test suite demonstrates how to effectively test a frontend component that interacts with a backend API to fetch and display data. It covers success cases, loading states, empty states, and error handling, ensuring a resilient user experience.\n\n### 1. Purpose & Importance of API Frontend Tests\n\nFrontend tests that interact with APIs are crucial for:\n*   **Verifying Integration:** Ensuring the frontend correctly calls the API, handles responses, and displays data as expected.\n*   **User Experience (UX) Validation:** Testing loading states, error messages, and empty data scenarios to confirm the user receives appropriate feedback.\n*   **Isolation from Backend:** Using mocks to isolate the frontend from the actual backend, making tests faster, more reliable, and independent of backend availability.\n*   **Regression Prevention:** Catching regressions early when API contracts or frontend logic changes.\n*   **Maintainability:** Providing clear examples of expected behavior for future developers.\n\n### 2. Assumptions & Technology Stack\n\n*   **Frontend Framework:** React (using functional components and `useEffect`).\n*   **Testing Framework:** Jest.\n*   **Testing Utilities:** React Testing Library (RTL) for rendering components and interacting with them in a user-centric way.\n*   **API Mocking:** `jest.spyOn(global, 'fetch')` for mocking the native `fetch` API. For more complex scenarios, libraries like `msw` (Mock Service Worker) or `jest-fetch-mock` are often used.\n*   **API Endpoint:** `/api/products` (GET request).\n*   **Scenario:** A `ProductList` component fetches a list of products and displays them.\n\n### 3. Frontend Component (`ProductList.js`)\n\nFirst, let's define the simplified React component we'll be testing.\n\n```javascript\n// src/components/ProductList.js\nimport React, { useEffect, useState } from 'react';\n\nconst ProductList = () => {\n  const [products, setProducts] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchProducts = async () => {\n      try {\n        const response = await fetch('/api/products');\n        if (!response.ok) {\n          // Handle non-2xx HTTP responses as errors\n          throw new Error(`HTTP error! status: ${response.status} ${response.statusText}`);\n        }\n        const data = await response.json();\n        setProducts(data);\n      } catch (e) {\n        // Handle network errors or issues parsing JSON\n        setError('Failed to fetch products. Please try again later.');\n        console.error('Error fetching products:', e);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchProducts();\n  }, []); // Empty dependency array means this runs once on mount\n\n  if (loading) {\n    return <div data-testid=\"loading-message\">Loading products...</div>;\n  }\n\n  if (error) {\n    return <div data-testid=\"error-message\">{error}</div>;\n  }\n\n  if (products.length === 0) {\n    return <div data-testid=\"no-products-message\">No products found.</div>;\n  }\n\n  return (\n    <div>\n      <h1>Product List</h1>\n      <ul data-testid=\"product-list\">\n        {products.map((product) => (\n          <li key={product.id}>{product.name} - ${product.price.toFixed(2)}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default ProductList;\n```\n\n### 4. API Frontend Test (`ProductList.test.js`)\n\nThis test file will mock the `fetch` API and use React Testing Library to render and interact with the `ProductList` component, asserting its behavior under different API responses.\n\n```javascript\n// src/components/ProductList.test.js\nimport { render, screen, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom'; // For extended matchers like .toBeInTheDocument()\nimport ProductList from './ProductList';\n\ndescribe('ProductList - API Frontend Test', () => {\n  // Use a variable to hold the mock fetch function\n  let mockFetch;\n\n  // beforeEach: Set up mocks before each test\n  beforeEach(() => {\n    // Spy on the global fetch function and replace it with a Jest mock function\n    mockFetch = jest.spyOn(global, 'fetch');\n  });\n\n  // afterEach: Clean up mocks after each test to ensure test isolation\n  afterEach(() => {\n    // Restore the original fetch implementation after each test\n    mockFetch.mockRestore();\n  });\n\n  // --- Test Case 1: Successful API fetch and data display ---\n  it('should display loading state initially, then products upon successful fetch', async () => {\n    // 1. Arrange: Define the mock API response for successful data\n    const mockProducts = [\n      { id: 1, name: 'Laptop', price: 1200.00 },\n      { id: 2, name: 'Wireless Mouse', price: 25.50 },\n      { id: 3, name: 'Keyboard', price: 75.00 },\n    ];\n\n    // Configure the mock fetch to resolve with our mock data\n    mockFetch.mockResolvedValueOnce({\n      ok: true, // Simulate a successful HTTP response (status 2xx)\n      json: () => Promise.resolve(mockProducts), // Return the mock JSON data\n      status: 200,\n      statusText: 'OK',\n    });\n\n    // 2. Act: Render the component\n    render(<ProductList />);\n\n    // 3. Assert (Initial State): Check for the loading message\n    expect(screen.getByTestId('loading-message')).toBeInTheDocument();\n    expect(screen.getByText('Loading products...')).toBeInTheDocument();\n\n    // 4. Assert (After API Call): Wait for the asynchronous update and check for products\n    // `waitFor` is essential for async operations in React Testing Library\n    await waitFor(() => {\n      // Ensure the loading message is gone\n      expect(screen.queryByTestId('loading-message')).not.toBeInTheDocument();\n      expect(screen.queryByText('Loading products...')).not.toBeInTheDocument();\n    });\n\n    // Check if the product list title and individual products are displayed\n    expect(screen.getByRole('heading', { name: /product list/i })).toBeInTheDocument();\n    expect(screen.getByTestId('product-list')).toBeInTheDocument();\n    expect(screen.getByText('Laptop - $1200.00')).toBeInTheDocument();\n    expect(screen.getByText('Wireless Mouse - $25.50')).toBeInTheDocument();\n    expect(screen.getByText('Keyboard - $75.00')).toBeInTheDocument();\n\n    // Verify the number of list items rendered\n    expect(screen.getAllByRole('listitem')).toHaveLength(mockProducts.length);\n\n    // Ensure fetch was called correctly\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n    expect(mockFetch).toHaveBeenCalledWith('/api/products');\n  });\n\n  // --- Test Case 2: API returns an empty array (no products) ---\n  it('should display \"No products found.\" if the API returns an empty array', async () => {\n    // 1. Arrange: Mock API to return an empty array\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve([]), // Simulate an empty product list\n      status: 200,\n      statusText: 'OK',\n    });\n\n    // 2. Act: Render the component\n    render(<ProductList />);\n\n    // 3. Assert: Wait for the component to update and check for the \"No products found.\" message\n    await waitFor(() => {\n      expect(screen.getByTestId('no-products-message')).toBeInTheDocument();\n      expect(screen.getByText('No products found.')).toBeInTheDocument();\n    });\n\n    // Ensure loading state is gone and no product list is rendered\n    expect(screen.queryByTestId('loading-message')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('product-list')).not.toBeInTheDocument();\n  });\n\n  // --- Test Case 3: API fetch fails (network error or bad HTTP status) ---\n  it('should display an error message if the API fetch fails', async () => {\n    // 1. Arrange: Mock API to simulate a network error or a non-OK HTTP response\n\n    // Option A: Simulate a network error (e.g., disconnected, CORS issue)\n    mockFetch.mockRejectedValueOnce(new Error('Failed to connect to network'));\n\n    // Option B: Simulate a server error (e.g., 500 Internal Server Error)\n    // mockFetch.mockResolvedValueOnce({\n    //   ok: false, // Indicate a non-successful HTTP response\n    //   status: 500,\n    //   statusText: 'Internal Server Error',\n    //   json: () => Promise.resolve({ message: 'Server error occurred' }), // Optional: if API sends an error body\n    // });\n\n    // 2. Act: Render the component\n    render(<ProductList />);\n\n    // 3. Assert: Wait for the error message to appear\n    await waitFor(() => {\n      expect(screen.getByTestId('error-message')).toBeInTheDocument();\n      expect(screen.getByText('Failed to fetch products. Please try again later.')).toBeInTheDocument();\n    });\n\n    // Ensure loading state is gone and no product list is rendered\n    expect(screen.queryByTestId('loading-message')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('product-list')).not.toBeInTheDocument();\n    expect(screen.queryByText('No products found.')).not.toBeInTheDocument();\n  });\n});\n```\n\n### 5. Best Practices & Considerations\n\n*   **User-Centric Testing (RTL):** React Testing Library encourages testing components the way a user would interact with them. Avoid testing internal state directly; focus on what the user sees and does.\n*   **Mocking Strategy:**\n    *   For simple `fetch` calls, `jest.spyOn(global, 'fetch')` is often sufficient.\n    *   For more complex APIs, multiple endpoints, or if you want to reuse mocks across different tests or even stories, consider using **Mock Service Worker (MSW)**. MSW intercepts network requests at the service worker level, allowing you to define powerful, persistent, and realistic API mocks that work across different testing environments (Jest, Cypress, Storybook, etc.).\n    *   `jest-fetch-mock` is another option specific to Jest for mocking `fetch`.\n*   **Test Data Management:** Use realistic but minimal mock data. For larger applications, consider factories or fixtures to generate test data.\n*   **Async Handling (`waitFor`):** Always use `await waitFor()` or `findBy*` queries from RTL when asserting against changes that happen after an asynchronous operation (like an API call). This prevents race conditions in your tests.\n*   **Clean Up Mocks:** Always `mockRestore()` or `resetHandlers()` (for MSW) after each test to ensure test isolation and prevent side effects from leaking between tests.\n*   **Error Boundaries:** For real applications, consider adding React Error Boundaries to gracefully catch rendering errors in child components. Test how your components behave when an error boundary catches an issue during data rendering.\n*   **Accessibility:** Use semantic HTML and `data-testid` attributes sparingly. Prioritize queries like `getByRole`, `getByText`, `getByLabelText`, which promote accessible code.\n*   **Edge Cases:** Beyond success and error, consider:\n    *   Very large datasets.\n    *   Pagination scenarios.\n    *   Rate limiting responses.\n    *   Authentication failures (401/403).\n    *   Timeouts.\n\nThis custom test suite provides a robust foundation for testing frontend components that interact with APIs, ensuring a high-quality and reliable application.",
          "score": 95.0,
          "is_valid": true,
          "errors": "<AsyncMock name='get_validation_service().validate_artifact().errors' id='2541673275920'>"
        }
      ]
    },
    "folder_id": null,
    "created_at": "2026-01-27T23:17:25.930605",
    "is_current": true
  }
]